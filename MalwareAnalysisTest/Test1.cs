using Microsoft.VisualStudio.TestTools.UnitTesting;
using System;
using System.Diagnostics;
using System.IO;
using System.Security.Principal;
using SMERH.core;

[TestClass]
public class MalwareAnalysisTests
{
    private static string _testFilePath;
    private static Process _monitoredProcess;
    private static string _observationLogPath = "Конспект по гитхабу.txt";
    private static TestContext _testContext;

    // Получаем TestContext для доступа к параметрам
    public TestContext TestContext { get; set; }

    [ClassInitialize]
    public static void ClassInitialize(TestContext testContext)
    {
        _testContext = testContext;

        // 1. Попробуем получить путь из параметров теста
        _testFilePath = testContext.Properties["TestFile"] as string;

        // 2. Если нет - из аргументов командной строки
        if (string.IsNullOrEmpty(_testFilePath))
        {
            var args = Environment.GetCommandLineArgs();
            for (int i = 0; i < args.Length; i++)
            {
                if (args[i] == "--TestFile" && i + 1 < args.Length)
                {
                    _testFilePath = args[i + 1];
                    break;
                }
            }
        }

        if (string.IsNullOrEmpty(_testFilePath))
        {
            throw new ArgumentNullException("TestFile", "Не указан путь к тестируемому файлу. Используйте --TestFile <path>");
        }

        if (!File.Exists(_testFilePath))
        {
            throw new FileNotFoundException($"Тестируемый файл не найден: {_testFilePath}");
        }

        InitializeObservationLog();
    }

    private static void InitializeObservationLog()
    {
        File.WriteAllText(_observationLogPath, $"=== Malware Analysis Log - {DateTime.Now} ===\n");
        File.AppendAllText(_observationLogPath, $"Target: {_testFilePath}\n");
        File.AppendAllText(_observationLogPath, $"OS: {Environment.OSVersion}\n");
        File.AppendAllText(_observationLogPath, $"User: {Environment.UserName}\n");
        File.AppendAllText(_observationLogPath, $"Admin: {IsAdministrator()}\n\n");
    }

    private static bool IsAdministrator()
    {
        using (var identity = WindowsIdentity.GetCurrent())
        {
            var principal = new WindowsPrincipal(identity);
            return principal.IsInRole(WindowsBuiltInRole.Administrator);
        }
    }

    private static void StartMonitoredProcess()
    {
        if (_monitoredProcess != null && !_monitoredProcess.HasExited)
        {
            _monitoredProcess.Kill();
            _monitoredProcess.Dispose();
        }

        _monitoredProcess = new Process
        {
            StartInfo = new ProcessStartInfo
            {
                FileName = _testFilePath,
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true,
                WindowStyle = ProcessWindowStyle.Hidden
            }
        };

        _monitoredProcess.OutputDataReceived += (sender, e) => LogObservation($"Output: {e.Data}");
        _monitoredProcess.ErrorDataReceived += (sender, e) => LogObservation($"Error: {e.Data}");

        _monitoredProcess.Start();
        _monitoredProcess.BeginOutputReadLine();
        _monitoredProcess.BeginErrorReadLine();

        LogObservation($"Process started. PID: {_monitoredProcess.Id}, Path: {_testFilePath}");
    }

    private static void LogObservation(string message)
    {
        try
        {
            File.AppendAllText(_observationLogPath, $"[{DateTime.Now:HH:mm:ss.fff}] {message}\n");
        }
        catch (Exception ex)
        {
            Debug.WriteLine($"Failed to log observation: {ex.Message}");
        }
    }

    [TestMethod]
    public void TestFileSystemChanges()
    {
        var filesBefore = Directory.GetFiles(Path.GetTempPath());
        StartMonitoredProcess();

        System.Threading.Thread.Sleep(3000); // Даем время на выполнение

        var filesAfter = Directory.GetFiles(Path.GetTempPath());
        LogObservation($"Files before: {filesBefore.Length}, after: {filesAfter.Length}");

        // Простая проверка - можно добавить более сложную логику сравнения
        Assert.IsTrue(filesAfter.Length >= filesBefore.Length,
            "Количество файлов в TEMP уменьшилось - возможно, вредонос удаляет файлы");
    }

    [TestMethod]
    public void TestProcessBehavior()
    {
        StartMonitoredProcess();
        System.Threading.Thread.Sleep(2000);

        try
        {
            var childProcesses = Process.GetProcesses();
            LogObservation($"Total processes running: {childProcesses.Length}");

            // Проверяем, остался ли процесс жив
            Assert.IsFalse(_monitoredProcess.HasExited,
                "Процесс завершился слишком быстро - возможно, это одноразовый исполняемый файл");
        }
        finally
        {
            foreach (var p in Process.GetProcessesByName(Path.GetFileNameWithoutExtension(_testFilePath)))
            {
                if (p.Id != _monitoredProcess.Id)
                {
                    p.Kill();
                    LogObservation($"Killed stray process: {p.Id}");
                }
            }
        }
    }

    [ClassCleanup]
    public static void ClassCleanup()
    {
        try
        {
            if (_monitoredProcess != null)
            {
                if (!_monitoredProcess.HasExited)
                {
                    _monitoredProcess.Kill();
                    LogObservation($"Process killed during cleanup. PID: {_monitoredProcess.Id}");
                }
                _monitoredProcess.Dispose();
            }

            File.AppendAllText(_observationLogPath, $"\n=== Analysis completed at {DateTime.Now} ===");
            Console.WriteLine($"Analysis log saved to: {Path.GetFullPath(_observationLogPath)}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Cleanup error: {ex.Message}");
        }
    }
}